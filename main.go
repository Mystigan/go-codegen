package main

import (
	"flag"
	"fmt"
	"go/types"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"unicode"
	"unicode/utf8"

	"github.com/alextanhongpin/pkg/stringcase"
	. "github.com/dave/jennifer/jen"
	"golang.org/x/tools/go/packages"
)

const NAME = "go-codegen"

func main() {
	// If the file name is provided, use the file name, else infer from struct.
	// go-codegen ./hello.go -type=User -out=../model/user.go -adapter=../adapter/user.go
	// go-codegen ./hello.go -type=User -out=../model -adapter=../adapter
	structPtr := flag.String("type", "", "the target struct name")
	inPtr := flag.String("in", "", "the input file, defaults to the file with the go:generate comment")
	outPtr := flag.String("out", "", "the output directory")
	adapterPtr := flag.String("adapter", "", "relative path to generate adapter")
	flag.Parse()

	structName := *structPtr
	if structName == "" {
		log.Fatal("-type cannot be empty")
	}
	fileName := stringcase.SnakeCase(structName) + ".go"
	genFileName := safeAddSuffixToFileName(fileName, "_gen")
	in := fullPath(*inPtr)
	in = safeAddFileName(in, fileName)
	// fmt.Println(in) // /path/from/go-generate/github.com/yourusername/pkgname/hello.go

	var out string
	if v := *outPtr; v == "" {
		out = in
	} else {
		out = fullPath(v)
	}
	out = safeAddFileName(out, genFileName)

	var adapter string
	if v := *adapterPtr; v != "" {
		adapter = fullPath(v)
		adapter = safeAddFileName(adapter, genFileName)
	}

	pkg := loadPackage(packagePath(in)) // github.com/yourusername/pkgname
	obj := pkg.Types.Scope().Lookup(structName)
	if obj == nil {
		log.Fatalf("struct %s not found", structName)
	}

	// Check if it is a declared type.
	if _, ok := obj.(*types.TypeName); !ok {
		log.Fatalf("%v is not a named type", obj)
	}

	// Check if the type is a struct.
	structType, ok := obj.Type().Underlying().(*types.Struct)
	if !ok {
		log.Fatalf("%v is not a struct", obj)
	}

	// Generate code.
	if err := generate(structName, structType, in, out, adapter); err != nil {
		log.Fatalf("generate failed: %s", err)
	}
}

func generate(structName string, structType *types.Struct, in, out, adapter string) error {
	structNameShort := strings.ToLower(structName[:1])
	// Start a new file in this package. Infer package name from output path.
	f := NewFile(packageName(out))

	// Add a comment.
	f.PackageComment(fmt.Sprintf("Code generated by %s, DO NOT EDIT.", NAME))
	type sortableCode struct {
		code         Code
		fieldPrivate string
		fieldPublic  string
		fieldType    string
	}
	var fields []sortableCode
	var lets []Code
	letsMapper := make(map[string]bool)

	// Build the struct fields.
	for i := 0; i < structType.NumFields(); i++ {
		field := structType.Field(i)
		//tagValue := structType.Tag(i)
		fieldPublic := field.Name()
		fieldPrivate := lowerFirst(fieldPublic)

		// TODO: Lowercase words like ID, JSON.
		if strings.ToUpper(fieldPublic) == fieldPublic {
			fieldPrivate = strings.ToLower(fieldPublic)
		}
		code := Id(fieldPrivate)

		var fieldType string
		switch v := field.Type().(type) {
		case *types.Basic:
			code.Id(v.String())
			fieldType = v.String()
		case *types.Pointer:
			code.Id(v.String())
			fieldType = v.String()
		case *types.Named:
			typeName := v.Obj()
			switch typeName.Pkg().Name() {
			case "sql":
				// NullTime, NullString ...
				switch name := typeName.Name(); name {
				case "NullTime":
					code.Qual("time", "Time")
					fieldType = "time.Time"

					// Handle initialization of sql NullTypes
					// var confirmedAt time.Time
					// if u.ConfirmedAt.Valid {
					//  confirmedAt = u.confirmedAt.Time
					// }
					let := Var().Id(fieldPrivate).Qual("time", "Time").Line()
					let.If().Id(structNameShort).Dot(fieldPublic).Dot("Valid").Block(
						Id(fieldPrivate).Op("=").Id(structNameShort).Dot(fieldPublic).Dot(strings.Replace(name, "Null", "", -1)),
					)
					lets = append(lets, let)
					letsMapper[fieldPrivate] = true
				default:
					underlyingType := strings.Replace(name, "Null", "", -1)
					code.Id(strings.ToLower(underlyingType))
					fieldType = strings.ToLower(underlyingType)

					let := Var().Id(fieldPrivate).Id(strings.ToLower(underlyingType)).Line()
					let.If().Id(structNameShort).Dot(fieldPublic).Dot("Valid").Block(
						Id(fieldPrivate).Op("=").Id(structNameShort).Dot(fieldPublic).Dot(underlyingType),
					)
					lets = append(lets, let)
					letsMapper[fieldPrivate] = true
				}
			default:
				// Qual import packages.
				code.Qual(
					typeName.Pkg().Path(),
					typeName.Name(),
				)
				fieldType = strings.Join([]string{
					typeName.Pkg().Name(),
					typeName.Name(),
				}, ".")
			}
		case *types.Slice:
			code.Id(v.String())
			fieldType = v.String()
		default:
			return fmt.Errorf("struct field type not handled: %T", v)
		}
		fields = append(fields, sortableCode{
			code:         code,
			fieldPrivate: fieldPrivate,
			fieldPublic:  fieldPublic,
			fieldType:    fieldType,
		})
	}

	var sortable bool
	sortable = true
	if sortable {
		sort.Slice(fields, func(i, j int) bool {
			return fields[i].fieldPrivate < fields[j].fieldPrivate
		})
	}

	codes := make([]Code, len(fields))
	for i := range fields {
		codes[i] = fields[i].code
	}

	// Generate a struct with the fields.
	f.Type().Id(structName).Struct(codes...)

	dict := Dict{}
	for i := range fields {
		name := fields[i].fieldPrivate
		dict[Id(name)] = Id(name)
	}
	factory := make([]Code, len(fields))
	for i := range fields {
		field := fields[i]
		if letsMapper[field.fieldPrivate] {
			factory[i] = Id(field.fieldPrivate)
		} else {
			factory[i] = Id(structNameShort).Dot(field.fieldPublic)
		}
	}

	// Generate the constructor for that field.
	f.Func().
		Id("New" + structName). // Function name.
		Params(codes...).       // Args.
		Id(structName).         // Return type.
		Block(
			Return(Id(structName).Values(dict)),
		).Line()

	if adapter != "" {
		f := NewFile(packageName(adapter))

		// Add a comment.
		f.PackageComment(fmt.Sprintf("Code generated by %s, DO NOT EDIT.", NAME))
		// Generate the adapter for that field.
		f.Func().
			Id("New"+structName).
			Params(Id(structNameShort).
				Qual(packagePath(in), structName)).
			Qual(packagePath(out), structName).Block(
			append(lets, Return(Qual(packagePath(out), "New"+structName).Call(List(factory...))))...,
		).Line()
		if err := f.Save(adapter); err != nil {
			log.Fatalf("save adapter failed: %s", err)
		}
	}

	// Generate getter methods.
	for i := range fields {
		field := fields[i]
		f.Func().Params(Id(structNameShort).Id(structName)).Id(field.fieldPublic).
			Params().
			Id(field.fieldType).Block(
			Return(Id(structNameShort).Dot(field.fieldPrivate)),
		).Line()
	}

	return f.Save(out)
}

func loadPackage(path string) *packages.Package {
	cfg := &packages.Config{
		Mode: packages.NeedTypes | packages.NeedImports,
	}
	pkgs, err := packages.Load(cfg, path)
	if err != nil {
		log.Fatalf("failed to load package: %v", err)
	}
	if packages.PrintErrors(pkgs) > 0 {
		os.Exit(1)
	}
	return pkgs[0]
}

// lowerFirst converts the first character to lowercase.
func lowerFirst(s string) string {
	if s == "" {
		return ""
	}
	r, n := utf8.DecodeRuneInString(s)
	return string(unicode.ToLower(r)) + s[n:]
}

func fullPath(rel string) string {
	path, err := os.Getwd()
	if err != nil {
		log.Fatalf("failed to get package directory: %v", err)
	}
	path = filepath.Join(path, rel)
	return path
}

func packagePath(path string) string {
	if ext := filepath.Ext(path); ext != "" {
		base := filepath.Base(path)
		path = path[:len(path)-len(base)]
	}
	if strings.HasSuffix(path, "/") {
		path = path[:len(path)-1]
	}
	idx := strings.Index(path, "github.com")
	return path[idx:]
}

func packageName(path string) string {
	return filepath.Base(packagePath(path))
}

func addSuffixToFileName(path, suffix string) string {
	ext := filepath.Ext(path)
	path = path[:len(path)-len(ext)]
	return path + suffix + ext
}

func safeAddSuffixToFileName(path, suffix string) string {
	if strings.Contains(path, suffix) {
		return path
	}
	return addSuffixToFileName(path, suffix)
}

func isFile(path string) bool {
	return filepath.Ext(path) != ""
}

func safeAddFileName(path, fileName string) string {
	if isFile(path) {
		return path
	}
	return filepath.Join(path, fileName)
}
