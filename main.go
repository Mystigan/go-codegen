package main

import (
	"flag"
	"fmt"
	"go/types"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"unicode"
	"unicode/utf8"

	. "github.com/dave/jennifer/jen"
	"golang.org/x/tools/go/packages"
)

func main() {
	structName := flag.String("type", "", "the name of the struct to target")
	pkgName := flag.String("pkg", "", "the target package name")
	out := flag.String("out", "", "the output directory")
	flag.Parse()

	path, err := os.Getwd()
	if err != nil {
		log.Fatalf("failed to get package directory: %v", err)
	}
	pkg := loadPackage(path)
	obj := pkg.Types.Scope().Lookup(*structName)
	if obj == nil {
		log.Fatalf("struct %s not found", *structName)
	}

	// Check if it is a declared type.
	if _, ok := obj.(*types.TypeName); !ok {
		log.Fatalf("%v is not a named type", obj)
	}

	// Check if the type is a struct.
	structType, ok := obj.Type().Underlying().(*types.Struct)
	if !ok {
		log.Fatalf("%v is not a struct", obj)
	}

	// Generate code.
	if err := generate(*structName, structType, *pkgName, *out); err != nil {
		panic(err)
	}
}

func generate(structName string, structType *types.Struct, pkgName, out string) error {
	// Get the package of the file with go:generate comment.
	goPackage := os.Getenv("GOPACKAGE")
	if pkgName != "" {
		goPackage = pkgName
	}

	// Start a new file in this package.
	f := NewFile(goPackage)
	f.PackageComment("Code generated by generator, DO NOT EDIT.")
	type sortableCode struct {
		code      Code
		fieldName string
		fieldType string
	}
	var fields []sortableCode

	// Build the struct fields.
	for i := 0; i < structType.NumFields(); i++ {
		field := structType.Field(i)
		//tagValue := structType.Tag(i)
		// Make name private
		fieldName := lowerFirst(field.Name())

		// TODO: Lowercase words like ID, JSON.
		if strings.ToUpper(field.Name()) == field.Name() {
			fieldName = strings.ToLower(field.Name())
		}
		code := Id(fieldName)

		var fieldType string
		switch v := field.Type().(type) {
		case *types.Basic:
			code.Id(v.String())
			fieldType = v.String()
		case *types.Pointer:
			code.Id(v.String())
			fieldType = v.String()
		case *types.Named:
			typeName := v.Obj()
			switch typeName.Pkg().Name() {
			case "sql":
				// NullTime, NullString ...
				switch name := typeName.Name(); name {
				case "NullTime":
					code.Op("*").Qual("time", "Time")
					fieldType = "*time.Time"
				default:
					underlyingType := strings.ToLower(strings.Replace(name, "Null", "", -1))
					code.Op("*").Id(underlyingType)
					fieldType = "*" + underlyingType
				}
			default:
				// Qual import packages.
				code.Qual(
					typeName.Pkg().Path(),
					typeName.Name(),
				)
				fieldType = strings.Join([]string{
					typeName.Pkg().Path(),
					typeName.Name(),
				}, ".")
			}
		default:
			return fmt.Errorf("struct field type not handled: %T", v)
		}
		fields = append(fields, sortableCode{
			code:      code,
			fieldName: fieldName,
			fieldType: fieldType,
		})
	}
	var sortable bool
	sortable = true
	if sortable {
		sort.Slice(fields, func(i, j int) bool {
			return fields[i].fieldName < fields[j].fieldName
		})
	}
	codes := make([]Code, len(fields))
	for i := range fields {
		codes[i] = fields[i].code
	}

	// Generate a struct with the fields.
	f.Type().Id(structName).Struct(codes...)

	dict := Dict{}
	for i := range fields {
		name := fields[i].fieldName
		dict[Id(name)] = Id(name)
	}

	// Generate the constructor for that field.
	f.Func().Id("New" + structName).Params(codes...).Block(
		Return(Op("&").Id(structName).Values(dict)),
	)

	// Build the go target file name.
	goFile := os.Getenv("GOFILE")
	if out != "" {
		goFile = out
	}
	log.Println("got gofile", goFile)
	ext := filepath.Ext(goFile)
	baseFilename := goFile[0 : len(goFile)-len(ext)]
	targetFilename := baseFilename + "_gen.go"
	return f.Save(targetFilename)
}

func loadPackage(path string) *packages.Package {
	cfg := &packages.Config{
		Mode: packages.NeedTypes | packages.NeedImports,
	}
	pkgs, err := packages.Load(cfg, path)
	if err != nil {
		log.Fatalf("failed to load package: %v", err)
	}
	if packages.PrintErrors(pkgs) > 0 {
		os.Exit(1)
	}
	return pkgs[0]
}

func lowerFirst(s string) string {
	if s == "" {
		return ""
	}
	r, n := utf8.DecodeRuneInString(s)
	return string(unicode.ToLower(r)) + s[n:]
}
